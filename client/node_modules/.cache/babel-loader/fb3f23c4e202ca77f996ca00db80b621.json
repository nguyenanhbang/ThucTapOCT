{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar ComponentModel = require(\"./Component\");\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * ECharts option manager\r\n *\r\n * @module {echarts/model/OptionManager}\r\n */\n\n\nvar each = zrUtil.each;\nvar clone = zrUtil.clone;\nvar map = zrUtil.map;\nvar merge = zrUtil.merge;\nvar QUERY_REG = /^(min|max)?(.+)$/;\n/**\r\n * TERM EXPLANATIONS:\r\n *\r\n * [option]:\r\n *\r\n *     An object that contains definitions of components. For example:\r\n *     var option = {\r\n *         title: {...},\r\n *         legend: {...},\r\n *         visualMap: {...},\r\n *         series: [\r\n *             {data: [...]},\r\n *             {data: [...]},\r\n *             ...\r\n *         ]\r\n *     };\r\n *\r\n * [rawOption]:\r\n *\r\n *     An object input to echarts.setOption. 'rawOption' may be an\r\n *     'option', or may be an object contains multi-options. For example:\r\n *     var option = {\r\n *         baseOption: {\r\n *             title: {...},\r\n *             legend: {...},\r\n *             series: [\r\n *                 {data: [...]},\r\n *                 {data: [...]},\r\n *                 ...\r\n *             ]\r\n *         },\r\n *         timeline: {...},\r\n *         options: [\r\n *             {title: {...}, series: {data: [...]}},\r\n *             {title: {...}, series: {data: [...]}},\r\n *             ...\r\n *         ],\r\n *         media: [\r\n *             {\r\n *                 query: {maxWidth: 320},\r\n *                 option: {series: {x: 20}, visualMap: {show: false}}\r\n *             },\r\n *             {\r\n *                 query: {minWidth: 320, maxWidth: 720},\r\n *                 option: {series: {x: 500}, visualMap: {show: true}}\r\n *             },\r\n *             {\r\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\r\n *             }\r\n *         ]\r\n *     };\r\n *\r\n * @alias module:echarts/model/OptionManager\r\n * @param {module:echarts/ExtensionAPI} api\r\n */\n\nfunction OptionManager(api) {\n  /**\r\n   * @private\r\n   * @type {module:echarts/ExtensionAPI}\r\n   */\n  this._api = api;\n  /**\r\n   * @private\r\n   * @type {Array.<number>}\r\n   */\n\n  this._timelineOptions = [];\n  /**\r\n   * @private\r\n   * @type {Array.<Object>}\r\n   */\n\n  this._mediaList = [];\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\n\n  this._mediaDefault;\n  /**\r\n   * -1, means default.\r\n   * empty means no media.\r\n   * @private\r\n   * @type {Array.<number>}\r\n   */\n\n  this._currentMediaIndices = [];\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\n\n  this._optionBackup;\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\n\n  this._newBaseOption;\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n\nOptionManager.prototype = {\n  constructor: OptionManager,\n\n  /**\r\n   * @public\r\n   * @param {Object} rawOption Raw option.\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @param {Array.<Function>} optionPreprocessorFuncs\r\n   * @return {Object} Init option\r\n   */\n  setOption: function setOption(rawOption, optionPreprocessorFuncs) {\n    if (rawOption) {\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\n      zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function (series) {\n        series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);\n      });\n    } // Caution: some series modify option data, if do not clone,\n    // it should ensure that the repeat modify correctly\n    // (create a new object when modify itself).\n\n\n    rawOption = clone(rawOption); // FIXME\n    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n    var oldOptionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (oldOptionBackup) {\n      // Only baseOption can be merged.\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n\n      if (newParsedOption.timelineOptions.length) {\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  },\n\n  /**\r\n   * @param {boolean} isRecreate\r\n   * @return {Object}\r\n   */\n  mountOption: function mountOption(isRecreate) {\n    var optionBackup = this._optionBackup; // TODO\n    // 如果没有reset功能则不clone。\n\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\n    this._mediaList = map(optionBackup.mediaList, clone);\n    this._mediaDefault = clone(optionBackup.mediaDefault);\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  },\n\n  /**\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @return {Object}\r\n   */\n  getTimelineOption: function getTimelineOption(ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n      }\n    }\n\n    return option;\n  },\n\n  /**\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @return {Array.<Object>}\r\n   */\n  getMediaOption: function getMediaOption(ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n  var timelineOptions = [];\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption; // Compatible with ec2.\n\n  var timelineOpt = rawOption.timeline;\n\n  if (rawOption.baseOption) {\n    baseOption = rawOption.baseOption;\n  } // For timeline\n\n\n  if (timelineOpt || rawOption.options) {\n    baseOption = baseOption || {};\n    timelineOptions = (rawOption.options || []).slice();\n  } // For media query\n\n\n  if (rawOption.media) {\n    baseOption = baseOption || {};\n    var media = rawOption.media;\n    each(media, function (singleMedia) {\n      if (singleMedia && singleMedia.option) {\n        if (singleMedia.query) {\n          mediaList.push(singleMedia);\n        } else if (!mediaDefault) {\n          // Use the first media default.\n          mediaDefault = singleMedia;\n        }\n      }\n    });\n  } // For normal option\n\n\n  if (!baseOption) {\n    baseOption = rawOption;\n  } // Set timelineOpt to baseOption in ec3,\n  // which is convenient for merge option.\n\n\n  if (!baseOption.timeline) {\n    baseOption.timeline = timelineOpt;\n  } // Preprocess.\n\n\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n    return media.option;\n  })), function (option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  });\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptions,\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\r\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\r\n * Support: width, height, aspectRatio\r\n * Can use max or min as prefix.\r\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  zrUtil.each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\r\n * Consider case:\r\n * `chart.setOption(opt1);`\r\n * Then user do some interaction like dataZoom, dataView changing.\r\n * `chart.setOption(opt2);`\r\n * Then user press 'reset button' in toolbox.\r\n *\r\n * After doing that all of the interaction effects should be reset, the\r\n * chart should be the same as the result of invoke\r\n * `chart.setOption(opt1); chart.setOption(opt2);`.\r\n *\r\n * Although it is not able ensure that\r\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\r\n * `chart.setOption(merge(opt1, opt2));` exactly,\r\n * this might be the only simple way to implement that feature.\r\n *\r\n * MEMO: We've considered some other approaches:\r\n * 1. Each model handle its self restoration but not uniform treatment.\r\n *     (Too complex in logic and error-prone)\r\n * 2. Use a shadow ecModel. (Performace expensive)\r\n */\n\n\nfunction mergeOption(oldOption, newOption) {\n  newOption = newOption || {};\n  each(newOption, function (newCptOpt, mainType) {\n    if (newCptOpt == null) {\n      return;\n    }\n\n    var oldCptOpt = oldOption[mainType];\n\n    if (!ComponentModel.hasClass(mainType)) {\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n    } else {\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n      oldOption[mainType] = map(mapResult, function (item) {\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n      });\n    }\n  });\n}\n\nvar _default = OptionManager;\nmodule.exports = _default;","map":null,"metadata":{},"sourceType":"script"}