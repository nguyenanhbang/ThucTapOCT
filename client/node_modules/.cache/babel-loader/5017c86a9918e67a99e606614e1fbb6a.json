{"ast":null,"code":"var fixShadow = require(\"./helper/fixShadow\");\n\nvar _constant = require(\"./constant\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function Style(opts) {\n  this.extendFrom(opts, false);\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  } // Fix NaN when rect is Infinity\n\n\n  x = isNaN(x) ? 0 : x;\n  x2 = isNaN(x2) ? 1 : x2;\n  y = isNaN(y) ? 0 : y;\n  y2 = isNaN(y2) ? 0 : y2;\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\r\n   * @type {string}\r\n   */\n  fill: '#000',\n\n  /**\r\n   * @type {string}\r\n   */\n  stroke: null,\n\n  /**\r\n   * @type {number}\r\n   */\n  opacity: 1,\n\n  /**\r\n   * @type {number}\r\n   */\n  fillOpacity: null,\n\n  /**\r\n   * @type {number}\r\n   */\n  strokeOpacity: null,\n\n  /**\r\n   * `true` is not supported.\r\n   * `false`/`null`/`undefined` are the same.\r\n   * `false` is used to remove lineDash in some\r\n   * case that `null`/`undefined` can not be set.\r\n   * (e.g., emphasis.lineStyle in echarts)\r\n   * @type {Array.<number>|boolean}\r\n   */\n  lineDash: null,\n\n  /**\r\n   * @type {number}\r\n   */\n  lineDashOffset: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  shadowBlur: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  shadowOffsetX: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  shadowOffsetY: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  lineWidth: 1,\n\n  /**\r\n   * If stroke ignore scale\r\n   * @type {Boolean}\r\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\r\n   * @type {string}\r\n   */\n  text: null,\n\n  /**\r\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\r\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\r\n   * So do not visit it directly in upper application (like echarts),\r\n   * but use `contain/text#makeFont` instead.\r\n   * @type {string}\r\n   */\n  font: null,\n\n  /**\r\n   * The same as font. Use font please.\r\n   * @deprecated\r\n   * @type {string}\r\n   */\n  textFont: null,\n\n  /**\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   * @type {string}\r\n   */\n  fontStyle: null,\n\n  /**\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   * @type {string}\r\n   */\n  fontWeight: null,\n\n  /**\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   * Should be 12 but not '12px'.\r\n   * @type {number}\r\n   */\n  fontSize: null,\n\n  /**\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   * @type {string}\r\n   */\n  fontFamily: null,\n\n  /**\r\n   * Reserved for special functinality, like 'hr'.\r\n   * @type {string}\r\n   */\n  textTag: null,\n\n  /**\r\n   * @type {string}\r\n   */\n  textFill: '#000',\n\n  /**\r\n   * @type {string}\r\n   */\n  textStroke: null,\n\n  /**\r\n   * @type {number}\r\n   */\n  textWidth: null,\n\n  /**\r\n   * Only for textBackground.\r\n   * @type {number}\r\n   */\n  textHeight: null,\n\n  /**\r\n   * textStroke may be set as some color as a default\r\n   * value in upper applicaion, where the default value\r\n   * of textStrokeWidth should be 0 to make sure that\r\n   * user can choose to do not use text stroke.\r\n   * @type {number}\r\n   */\n  textStrokeWidth: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  textLineHeight: null,\n\n  /**\r\n   * 'inside', 'left', 'right', 'top', 'bottom'\r\n   * [x, y]\r\n   * Based on x, y of rect.\r\n   * @type {string|Array.<number>}\r\n   * @default 'inside'\r\n   */\n  textPosition: 'inside',\n\n  /**\r\n   * If not specified, use the boundingRect of a `displayable`.\r\n   * @type {Object}\r\n   */\n  textRect: null,\n\n  /**\r\n   * [x, y]\r\n   * @type {Array.<number>}\r\n   */\n  textOffset: null,\n\n  /**\r\n   * @type {string}\r\n   */\n  textAlign: null,\n\n  /**\r\n   * @type {string}\r\n   */\n  textVerticalAlign: null,\n\n  /**\r\n   * @type {number}\r\n   */\n  textDistance: 5,\n\n  /**\r\n   * @type {string}\r\n   */\n  textShadowColor: 'transparent',\n\n  /**\r\n   * @type {number}\r\n   */\n  textShadowBlur: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  textShadowOffsetX: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  textShadowOffsetY: 0,\n\n  /**\r\n   * @type {string}\r\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\r\n   * @type {number}\r\n   */\n  textBoxShadowBlur: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\r\n   * Whether transform text.\r\n   * Only available in Path and Image element,\r\n   * where the text is called as `RectText`.\r\n   * @type {boolean}\r\n   */\n  transformText: false,\n\n  /**\r\n   * Text rotate around position of Path or Image.\r\n   * The origin of the rotation can be specified by `textOrigin`.\r\n   * Only available in Path and Image element,\r\n   * where the text is called as `RectText`.\r\n   */\n  textRotation: 0,\n\n  /**\r\n   * Text origin of text rotation.\r\n   * Useful in the case like label rotation of circular symbol.\r\n   * Only available in Path and Image element, where the text is called\r\n   * as `RectText` and the element is called as \"host element\".\r\n   * The value can be:\r\n   * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`\r\n   * base on the left-top corner of the rect of its host element.\r\n   * + If specified as a string `center`, it is the center of the rect of\r\n   * its host element.\r\n   * + By default, this origin is the `textPosition`.\r\n   * @type {string|Array.<number>}\r\n   */\n  textOrigin: null,\n\n  /**\r\n   * @type {string}\r\n   */\n  textBackgroundColor: null,\n\n  /**\r\n   * @type {string}\r\n   */\n  textBorderColor: null,\n\n  /**\r\n   * @type {number}\r\n   */\n  textBorderWidth: 0,\n\n  /**\r\n   * @type {number}\r\n   */\n  textBorderRadius: 0,\n\n  /**\r\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\r\n   * @type {number|Array.<number>}\r\n   */\n  textPadding: null,\n\n  /**\r\n   * Text styles for rich text.\r\n   * @type {Object}\r\n   */\n  rich: null,\n\n  /**\r\n   * {outerWidth, outerHeight, ellipsis, placeholder}\r\n   * @type {Object}\r\n   */\n  truncate: null,\n\n  /**\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\r\n   * @type {string}\r\n   */\n  blend: null,\n\n  /**\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   */\n  bind: function bind(ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style; // If no prevStyle, it means first draw.\n    // Only apply cache if the last time cachced by this function.\n\n    var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy.STYLE_BIND;\n    ctx.__attrCachedBy = ContextCachedBy.STYLE_BIND;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (notCheckCache || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);\n      }\n    }\n\n    if (notCheckCache || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (notCheckCache || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (notCheckCache || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (notCheckCache || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function hasFill() {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function hasStroke() {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\r\n   * Extend from other style\r\n   * @param {zrender/graphic/Style} otherStyle\r\n   * @param {boolean} overwrite true: overwrirte any way.\r\n   *                            false: overwrite only when !target.hasOwnProperty\r\n   *                            others: overwrite when property is not null/undefined.\r\n   */\n  extendFrom: function extendFrom(otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Batch setting style with a given object\r\n   * @param {Object|string} obj\r\n   * @param {*} [obj]\r\n   */\n  set: function set(obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\r\n   * Clone\r\n   * @return {zrender/graphic/Style} [description]\r\n   */\n  clone: function clone() {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function getGradient(ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;","map":null,"metadata":{},"sourceType":"script"}