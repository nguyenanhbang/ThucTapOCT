{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _clazz = require(\"../util/clazz\");\n\nvar enableClassCheck = _clazz.enableClassCheck;\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// id may be function name of Object, add a prefix to avoid this problem.\n\nfunction generateNodeKey(id) {\n  return '_EC_' + id;\n}\n/**\r\n * @alias module:echarts/data/Graph\r\n * @constructor\r\n * @param {boolean} directed\r\n */\n\n\nvar Graph = function Graph(directed) {\n  /**\r\n   * 是否是有向图\r\n   * @type {boolean}\r\n   * @private\r\n   */\n  this._directed = directed || false;\n  /**\r\n   * @type {Array.<module:echarts/data/Graph.Node>}\r\n   * @readOnly\r\n   */\n\n  this.nodes = [];\n  /**\r\n   * @type {Array.<module:echarts/data/Graph.Edge>}\r\n   * @readOnly\r\n   */\n\n  this.edges = [];\n  /**\r\n   * @type {Object.<string, module:echarts/data/Graph.Node>}\r\n   * @private\r\n   */\n\n  this._nodesMap = {};\n  /**\r\n   * @type {Object.<string, module:echarts/data/Graph.Edge>}\r\n   * @private\r\n   */\n\n  this._edgesMap = {};\n  /**\r\n   * @type {module:echarts/data/List}\r\n   * @readOnly\r\n   */\n\n  this.data;\n  /**\r\n   * @type {module:echarts/data/List}\r\n   * @readOnly\r\n   */\n\n  this.edgeData;\n};\n\nvar graphProto = Graph.prototype;\n/**\r\n * @type {string}\r\n */\n\ngraphProto.type = 'graph';\n/**\r\n * If is directed graph\r\n * @return {boolean}\r\n */\n\ngraphProto.isDirected = function () {\n  return this._directed;\n};\n/**\r\n * Add a new node\r\n * @param {string} id\r\n * @param {number} [dataIndex]\r\n */\n\n\ngraphProto.addNode = function (id, dataIndex) {\n  id = id == null ? '' + dataIndex : '' + id;\n  var nodesMap = this._nodesMap;\n\n  if (nodesMap[generateNodeKey(id)]) {\n    return;\n  }\n\n  var node = new Node(id, dataIndex);\n  node.hostGraph = this;\n  this.nodes.push(node);\n  nodesMap[generateNodeKey(id)] = node;\n  return node;\n};\n/**\r\n * Get node by data index\r\n * @param  {number} dataIndex\r\n * @return {module:echarts/data/Graph~Node}\r\n */\n\n\ngraphProto.getNodeByIndex = function (dataIndex) {\n  var rawIdx = this.data.getRawIndex(dataIndex);\n  return this.nodes[rawIdx];\n};\n/**\r\n * Get node by id\r\n * @param  {string} id\r\n * @return {module:echarts/data/Graph.Node}\r\n */\n\n\ngraphProto.getNodeById = function (id) {\n  return this._nodesMap[generateNodeKey(id)];\n};\n/**\r\n * Add a new edge\r\n * @param {number|string|module:echarts/data/Graph.Node} n1\r\n * @param {number|string|module:echarts/data/Graph.Node} n2\r\n * @param {number} [dataIndex=-1]\r\n * @return {module:echarts/data/Graph.Edge}\r\n */\n\n\ngraphProto.addEdge = function (n1, n2, dataIndex) {\n  var nodesMap = this._nodesMap;\n  var edgesMap = this._edgesMap; // PNEDING\n\n  if (typeof n1 === 'number') {\n    n1 = this.nodes[n1];\n  }\n\n  if (typeof n2 === 'number') {\n    n2 = this.nodes[n2];\n  }\n\n  if (!Node.isInstance(n1)) {\n    n1 = nodesMap[generateNodeKey(n1)];\n  }\n\n  if (!Node.isInstance(n2)) {\n    n2 = nodesMap[generateNodeKey(n2)];\n  }\n\n  if (!n1 || !n2) {\n    return;\n  }\n\n  var key = n1.id + '-' + n2.id;\n  var edge = new Edge(n1, n2, dataIndex);\n  edge.hostGraph = this;\n\n  if (this._directed) {\n    n1.outEdges.push(edge);\n    n2.inEdges.push(edge);\n  }\n\n  n1.edges.push(edge);\n\n  if (n1 !== n2) {\n    n2.edges.push(edge);\n  }\n\n  this.edges.push(edge);\n  edgesMap[key] = edge;\n  return edge;\n};\n/**\r\n * Get edge by data index\r\n * @param  {number} dataIndex\r\n * @return {module:echarts/data/Graph~Node}\r\n */\n\n\ngraphProto.getEdgeByIndex = function (dataIndex) {\n  var rawIdx = this.edgeData.getRawIndex(dataIndex);\n  return this.edges[rawIdx];\n};\n/**\r\n * Get edge by two linked nodes\r\n * @param  {module:echarts/data/Graph.Node|string} n1\r\n * @param  {module:echarts/data/Graph.Node|string} n2\r\n * @return {module:echarts/data/Graph.Edge}\r\n */\n\n\ngraphProto.getEdge = function (n1, n2) {\n  if (Node.isInstance(n1)) {\n    n1 = n1.id;\n  }\n\n  if (Node.isInstance(n2)) {\n    n2 = n2.id;\n  }\n\n  var edgesMap = this._edgesMap;\n\n  if (this._directed) {\n    return edgesMap[n1 + '-' + n2];\n  } else {\n    return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];\n  }\n};\n/**\r\n * Iterate all nodes\r\n * @param  {Function} cb\r\n * @param  {*} [context]\r\n */\n\n\ngraphProto.eachNode = function (cb, context) {\n  var nodes = this.nodes;\n  var len = nodes.length;\n\n  for (var i = 0; i < len; i++) {\n    if (nodes[i].dataIndex >= 0) {\n      cb.call(context, nodes[i], i);\n    }\n  }\n};\n/**\r\n * Iterate all edges\r\n * @param  {Function} cb\r\n * @param  {*} [context]\r\n */\n\n\ngraphProto.eachEdge = function (cb, context) {\n  var edges = this.edges;\n  var len = edges.length;\n\n  for (var i = 0; i < len; i++) {\n    if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {\n      cb.call(context, edges[i], i);\n    }\n  }\n};\n/**\r\n * Breadth first traverse\r\n * @param {Function} cb\r\n * @param {module:echarts/data/Graph.Node} startNode\r\n * @param {string} [direction='none'] 'none'|'in'|'out'\r\n * @param {*} [context]\r\n */\n\n\ngraphProto.breadthFirstTraverse = function (cb, startNode, direction, context) {\n  if (!Node.isInstance(startNode)) {\n    startNode = this._nodesMap[generateNodeKey(startNode)];\n  }\n\n  if (!startNode) {\n    return;\n  }\n\n  var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';\n\n  for (var i = 0; i < this.nodes.length; i++) {\n    this.nodes[i].__visited = false;\n  }\n\n  if (cb.call(context, startNode, null)) {\n    return;\n  }\n\n  var queue = [startNode];\n\n  while (queue.length) {\n    var currentNode = queue.shift();\n    var edges = currentNode[edgeType];\n\n    for (var i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      var otherNode = e.node1 === currentNode ? e.node2 : e.node1;\n\n      if (!otherNode.__visited) {\n        if (cb.call(context, otherNode, currentNode)) {\n          // Stop traversing\n          return;\n        }\n\n        queue.push(otherNode);\n        otherNode.__visited = true;\n      }\n    }\n  }\n}; // TODO\n// graphProto.depthFirstTraverse = function (\n//     cb, startNode, direction, context\n// ) {\n// };\n// Filter update\n\n\ngraphProto.update = function () {\n  var data = this.data;\n  var edgeData = this.edgeData;\n  var nodes = this.nodes;\n  var edges = this.edges;\n\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    nodes[i].dataIndex = -1;\n  }\n\n  for (var i = 0, len = data.count(); i < len; i++) {\n    nodes[data.getRawIndex(i)].dataIndex = i;\n  }\n\n  edgeData.filterSelf(function (idx) {\n    var edge = edges[edgeData.getRawIndex(idx)];\n    return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;\n  }); // Update edge\n\n  for (var i = 0, len = edges.length; i < len; i++) {\n    edges[i].dataIndex = -1;\n  }\n\n  for (var i = 0, len = edgeData.count(); i < len; i++) {\n    edges[edgeData.getRawIndex(i)].dataIndex = i;\n  }\n};\n/**\r\n * @return {module:echarts/data/Graph}\r\n */\n\n\ngraphProto.clone = function () {\n  var graph = new Graph(this._directed);\n  var nodes = this.nodes;\n  var edges = this.edges;\n\n  for (var i = 0; i < nodes.length; i++) {\n    graph.addNode(nodes[i].id, nodes[i].dataIndex);\n  }\n\n  for (var i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);\n  }\n\n  return graph;\n};\n/**\r\n * @alias module:echarts/data/Graph.Node\r\n */\n\n\nfunction Node(id, dataIndex) {\n  /**\r\n  * @type {string}\r\n  */\n  this.id = id == null ? '' : id;\n  /**\r\n  * @type {Array.<module:echarts/data/Graph.Edge>}\r\n  */\n\n  this.inEdges = [];\n  /**\r\n  * @type {Array.<module:echarts/data/Graph.Edge>}\r\n  */\n\n  this.outEdges = [];\n  /**\r\n  * @type {Array.<module:echarts/data/Graph.Edge>}\r\n  */\n\n  this.edges = [];\n  /**\r\n   * @type {module:echarts/data/Graph}\r\n   */\n\n  this.hostGraph;\n  /**\r\n   * @type {number}\r\n   */\n\n  this.dataIndex = dataIndex == null ? -1 : dataIndex;\n}\n\nNode.prototype = {\n  constructor: Node,\n\n  /**\r\n   * @return {number}\r\n   */\n  degree: function degree() {\n    return this.edges.length;\n  },\n\n  /**\r\n   * @return {number}\r\n   */\n  inDegree: function inDegree() {\n    return this.inEdges.length;\n  },\n\n  /**\r\n  * @return {number}\r\n  */\n  outDegree: function outDegree() {\n    return this.outEdges.length;\n  },\n\n  /**\r\n   * @param {string} [path]\r\n   * @return {module:echarts/model/Model}\r\n   */\n  getModel: function getModel(path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var graph = this.hostGraph;\n    var itemModel = graph.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  }\n};\n/**\r\n * 图边\r\n * @alias module:echarts/data/Graph.Edge\r\n * @param {module:echarts/data/Graph.Node} n1\r\n * @param {module:echarts/data/Graph.Node} n2\r\n * @param {number} [dataIndex=-1]\r\n */\n\nfunction Edge(n1, n2, dataIndex) {\n  /**\r\n   * 节点1，如果是有向图则为源节点\r\n   * @type {module:echarts/data/Graph.Node}\r\n   */\n  this.node1 = n1;\n  /**\r\n   * 节点2，如果是有向图则为目标节点\r\n   * @type {module:echarts/data/Graph.Node}\r\n   */\n\n  this.node2 = n2;\n  this.dataIndex = dataIndex == null ? -1 : dataIndex;\n}\n/**\r\n * @param {string} [path]\r\n * @return {module:echarts/model/Model}\r\n */\n\n\nEdge.prototype.getModel = function (path) {\n  if (this.dataIndex < 0) {\n    return;\n  }\n\n  var graph = this.hostGraph;\n  var itemModel = graph.edgeData.getItemModel(this.dataIndex);\n  return itemModel.getModel(path);\n};\n\nvar createGraphDataProxyMixin = function createGraphDataProxyMixin(hostName, dataName) {\n  return {\n    /**\r\n     * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.\r\n     * @return {number}\r\n     */\n    getValue: function getValue(dimension) {\n      var data = this[hostName][dataName];\n      return data.get(data.getDimension(dimension || 'value'), this.dataIndex);\n    },\n\n    /**\r\n     * @param {Object|string} key\r\n     * @param {*} [value]\r\n     */\n    setVisual: function setVisual(key, value) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);\n    },\n\n    /**\r\n     * @param {string} key\r\n     * @return {boolean}\r\n     */\n    getVisual: function getVisual(key, ignoreParent) {\n      return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);\n    },\n\n    /**\r\n     * @param {Object} layout\r\n     * @return {boolean} [merge=false]\r\n     */\n    setLayout: function setLayout(layout, merge) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);\n    },\n\n    /**\r\n     * @return {Object}\r\n     */\n    getLayout: function getLayout() {\n      return this[hostName][dataName].getItemLayout(this.dataIndex);\n    },\n\n    /**\r\n     * @return {module:zrender/Element}\r\n     */\n    getGraphicEl: function getGraphicEl() {\n      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);\n    },\n\n    /**\r\n     * @return {number}\r\n     */\n    getRawIndex: function getRawIndex() {\n      return this[hostName][dataName].getRawIndex(this.dataIndex);\n    }\n  };\n};\n\nzrUtil.mixin(Node, createGraphDataProxyMixin('hostGraph', 'data'));\nzrUtil.mixin(Edge, createGraphDataProxyMixin('hostGraph', 'edgeData'));\nGraph.Node = Node;\nGraph.Edge = Edge;\nenableClassCheck(Node);\nenableClassCheck(Edge);\nvar _default = Graph;\nmodule.exports = _default;","map":null,"metadata":{},"sourceType":"script"}